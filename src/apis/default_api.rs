/*
 * opencode
 *
 * opencode api
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`app_agents`]
#[derive(Clone, Debug)]
pub struct AppAgentsParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`app_log`]
#[derive(Clone, Debug)]
pub struct AppLogParams {
    pub directory: Option<String>,
    pub app_log_request: Option<models::AppLogRequest>
}

/// struct for passing parameters to the method [`app_skills`]
#[derive(Clone, Debug)]
pub struct AppSkillsParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`auth_remove`]
#[derive(Clone, Debug)]
pub struct AuthRemoveParams {
    pub provider_id: String
}

/// struct for passing parameters to the method [`auth_set`]
#[derive(Clone, Debug)]
pub struct AuthSetParams {
    pub provider_id: String,
    pub auth: Option<models::Auth>
}

/// struct for passing parameters to the method [`command_list`]
#[derive(Clone, Debug)]
pub struct CommandListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`config_get`]
#[derive(Clone, Debug)]
pub struct ConfigGetParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`config_providers`]
#[derive(Clone, Debug)]
pub struct ConfigProvidersParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`config_update`]
#[derive(Clone, Debug)]
pub struct ConfigUpdateParams {
    pub directory: Option<String>,
    pub config: Option<models::Config>
}

/// struct for passing parameters to the method [`event_subscribe`]
#[derive(Clone, Debug)]
pub struct EventSubscribeParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`experimental_resource_list`]
#[derive(Clone, Debug)]
pub struct ExperimentalResourceListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`file_list`]
#[derive(Clone, Debug)]
pub struct FileListParams {
    pub path: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`file_read`]
#[derive(Clone, Debug)]
pub struct FileReadParams {
    pub path: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`file_status`]
#[derive(Clone, Debug)]
pub struct FileStatusParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`find_files`]
#[derive(Clone, Debug)]
pub struct FindFilesParams {
    pub query: String,
    pub directory: Option<String>,
    pub dirs: Option<String>,
    pub r#type: Option<String>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`find_symbols`]
#[derive(Clone, Debug)]
pub struct FindSymbolsParams {
    pub query: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`find_text`]
#[derive(Clone, Debug)]
pub struct FindTextParams {
    pub pattern: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`formatter_status`]
#[derive(Clone, Debug)]
pub struct FormatterStatusParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`global_config_update`]
#[derive(Clone, Debug)]
pub struct GlobalConfigUpdateParams {
    pub config: Option<models::Config>
}

/// struct for passing parameters to the method [`instance_dispose`]
#[derive(Clone, Debug)]
pub struct InstanceDisposeParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`lsp_status`]
#[derive(Clone, Debug)]
pub struct LspStatusParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_add`]
#[derive(Clone, Debug)]
pub struct McpAddParams {
    pub directory: Option<String>,
    pub mcp_add_request: Option<models::McpAddRequest>
}

/// struct for passing parameters to the method [`mcp_auth_authenticate`]
#[derive(Clone, Debug)]
pub struct McpAuthAuthenticateParams {
    pub name: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_auth_callback`]
#[derive(Clone, Debug)]
pub struct McpAuthCallbackParams {
    pub name: String,
    pub directory: Option<String>,
    pub mcp_auth_callback_request: Option<models::McpAuthCallbackRequest>
}

/// struct for passing parameters to the method [`mcp_auth_remove`]
#[derive(Clone, Debug)]
pub struct McpAuthRemoveParams {
    pub name: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_auth_start`]
#[derive(Clone, Debug)]
pub struct McpAuthStartParams {
    pub name: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_connect`]
#[derive(Clone, Debug)]
pub struct McpConnectParams {
    pub name: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_disconnect`]
#[derive(Clone, Debug)]
pub struct McpDisconnectParams {
    pub name: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`mcp_status`]
#[derive(Clone, Debug)]
pub struct McpStatusParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`part_delete`]
#[derive(Clone, Debug)]
pub struct PartDeleteParams {
    /// Session ID
    pub session_id: String,
    /// Message ID
    pub message_id: String,
    /// Part ID
    pub part_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`part_update`]
#[derive(Clone, Debug)]
pub struct PartUpdateParams {
    /// Session ID
    pub session_id: String,
    /// Message ID
    pub message_id: String,
    /// Part ID
    pub part_id: String,
    pub directory: Option<String>,
    pub part: Option<models::Part>
}

/// struct for passing parameters to the method [`path_get`]
#[derive(Clone, Debug)]
pub struct PathGetParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`permission_list`]
#[derive(Clone, Debug)]
pub struct PermissionListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`permission_reply`]
#[derive(Clone, Debug)]
pub struct PermissionReplyParams {
    pub request_id: String,
    pub directory: Option<String>,
    pub permission_reply_request: Option<models::PermissionReplyRequest>
}

/// struct for passing parameters to the method [`permission_respond`]
#[derive(Clone, Debug)]
pub struct PermissionRespondParams {
    pub session_id: String,
    pub permission_id: String,
    pub directory: Option<String>,
    pub permission_respond_request: Option<models::PermissionRespondRequest>
}

/// struct for passing parameters to the method [`project_current`]
#[derive(Clone, Debug)]
pub struct ProjectCurrentParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`project_list`]
#[derive(Clone, Debug)]
pub struct ProjectListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`project_update`]
#[derive(Clone, Debug)]
pub struct ProjectUpdateParams {
    pub project_id: String,
    pub directory: Option<String>,
    pub project_update_request: Option<models::ProjectUpdateRequest>
}

/// struct for passing parameters to the method [`provider_auth`]
#[derive(Clone, Debug)]
pub struct ProviderAuthParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`provider_list`]
#[derive(Clone, Debug)]
pub struct ProviderListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`provider_oauth_authorize`]
#[derive(Clone, Debug)]
pub struct ProviderOauthAuthorizeParams {
    /// Provider ID
    pub provider_id: String,
    pub directory: Option<String>,
    pub provider_oauth_authorize_request: Option<models::ProviderOauthAuthorizeRequest>
}

/// struct for passing parameters to the method [`provider_oauth_callback`]
#[derive(Clone, Debug)]
pub struct ProviderOauthCallbackParams {
    /// Provider ID
    pub provider_id: String,
    pub directory: Option<String>,
    pub provider_oauth_callback_request: Option<models::ProviderOauthCallbackRequest>
}

/// struct for passing parameters to the method [`pty_connect`]
#[derive(Clone, Debug)]
pub struct PtyConnectParams {
    pub pty_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`pty_create`]
#[derive(Clone, Debug)]
pub struct PtyCreateParams {
    pub directory: Option<String>,
    pub pty_create_request: Option<models::PtyCreateRequest>
}

/// struct for passing parameters to the method [`pty_get`]
#[derive(Clone, Debug)]
pub struct PtyGetParams {
    pub pty_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`pty_list`]
#[derive(Clone, Debug)]
pub struct PtyListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`pty_remove`]
#[derive(Clone, Debug)]
pub struct PtyRemoveParams {
    pub pty_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`pty_update`]
#[derive(Clone, Debug)]
pub struct PtyUpdateParams {
    pub pty_id: String,
    pub directory: Option<String>,
    pub pty_update_request: Option<models::PtyUpdateRequest>
}

/// struct for passing parameters to the method [`question_list`]
#[derive(Clone, Debug)]
pub struct QuestionListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`question_reject`]
#[derive(Clone, Debug)]
pub struct QuestionRejectParams {
    pub request_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`question_reply`]
#[derive(Clone, Debug)]
pub struct QuestionReplyParams {
    pub request_id: String,
    pub directory: Option<String>,
    pub question_reply_request: Option<models::QuestionReplyRequest>
}

/// struct for passing parameters to the method [`session_abort`]
#[derive(Clone, Debug)]
pub struct SessionAbortParams {
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_command`]
#[derive(Clone, Debug)]
pub struct SessionCommandParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_command_request: Option<models::SessionCommandRequest>
}

/// struct for passing parameters to the method [`session_create`]
#[derive(Clone, Debug)]
pub struct SessionCreateParams {
    pub directory: Option<String>,
    pub session_create_request: Option<models::SessionCreateRequest>
}

/// struct for passing parameters to the method [`session_delete`]
#[derive(Clone, Debug)]
pub struct SessionDeleteParams {
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_diff`]
#[derive(Clone, Debug)]
pub struct SessionDiffParams {
    pub session_id: String,
    pub directory: Option<String>,
    pub message_id: Option<String>
}

/// struct for passing parameters to the method [`session_fork`]
#[derive(Clone, Debug)]
pub struct SessionForkParams {
    pub session_id: String,
    pub directory: Option<String>,
    pub session_fork_request: Option<models::SessionForkRequest>
}

/// struct for passing parameters to the method [`session_init`]
#[derive(Clone, Debug)]
pub struct SessionInitParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_init_request: Option<models::SessionInitRequest>
}

/// struct for passing parameters to the method [`session_list`]
#[derive(Clone, Debug)]
pub struct SessionListParams {
    /// Filter sessions by project directory
    pub directory: Option<String>,
    /// Only return root sessions (no parentID)
    pub roots: Option<bool>,
    /// Filter sessions updated on or after this timestamp (milliseconds since epoch)
    pub start: Option<f64>,
    /// Filter sessions by title (case-insensitive)
    pub search: Option<String>,
    /// Maximum number of sessions to return
    pub limit: Option<f64>
}

/// struct for passing parameters to the method [`session_message`]
#[derive(Clone, Debug)]
pub struct SessionMessageParams {
    /// Session ID
    pub session_id: String,
    /// Message ID
    pub message_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_messages`]
#[derive(Clone, Debug)]
pub struct SessionMessagesParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub limit: Option<f64>
}

/// struct for passing parameters to the method [`session_prompt`]
#[derive(Clone, Debug)]
pub struct SessionPromptParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_prompt_request: Option<models::SessionPromptRequest>
}

/// struct for passing parameters to the method [`session_prompt_async`]
#[derive(Clone, Debug)]
pub struct SessionPromptAsyncParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_prompt_request: Option<models::SessionPromptRequest>
}

/// struct for passing parameters to the method [`session_revert`]
#[derive(Clone, Debug)]
pub struct SessionRevertParams {
    pub session_id: String,
    pub directory: Option<String>,
    pub session_revert_request: Option<models::SessionRevertRequest>
}

/// struct for passing parameters to the method [`session_share`]
#[derive(Clone, Debug)]
pub struct SessionShareParams {
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_shell`]
#[derive(Clone, Debug)]
pub struct SessionShellParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_shell_request: Option<models::SessionShellRequest>
}

/// struct for passing parameters to the method [`session_status`]
#[derive(Clone, Debug)]
pub struct SessionStatusParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_summarize`]
#[derive(Clone, Debug)]
pub struct SessionSummarizeParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>,
    pub session_summarize_request: Option<models::SessionSummarizeRequest>
}

/// struct for passing parameters to the method [`session_todo`]
#[derive(Clone, Debug)]
pub struct SessionTodoParams {
    /// Session ID
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_unrevert`]
#[derive(Clone, Debug)]
pub struct SessionUnrevertParams {
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_unshare`]
#[derive(Clone, Debug)]
pub struct SessionUnshareParams {
    pub session_id: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`session_update`]
#[derive(Clone, Debug)]
pub struct SessionUpdateParams {
    pub session_id: String,
    pub directory: Option<String>,
    pub session_update_request: Option<models::SessionUpdateRequest>
}

/// struct for passing parameters to the method [`tool_ids`]
#[derive(Clone, Debug)]
pub struct ToolIdsParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tool_list`]
#[derive(Clone, Debug)]
pub struct ToolListParams {
    pub provider: String,
    pub model: String,
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_append_prompt`]
#[derive(Clone, Debug)]
pub struct TuiAppendPromptParams {
    pub directory: Option<String>,
    pub find_text200_response_inner_path: Option<models::FindText200ResponseInnerPath>
}

/// struct for passing parameters to the method [`tui_clear_prompt`]
#[derive(Clone, Debug)]
pub struct TuiClearPromptParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_control_next`]
#[derive(Clone, Debug)]
pub struct TuiControlNextParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_control_response`]
#[derive(Clone, Debug)]
pub struct TuiControlResponseParams {
    pub directory: Option<String>,
    pub body: Option<serde_json::Value>
}

/// struct for passing parameters to the method [`tui_execute_command`]
#[derive(Clone, Debug)]
pub struct TuiExecuteCommandParams {
    pub directory: Option<String>,
    pub tui_execute_command_request: Option<models::TuiExecuteCommandRequest>
}

/// struct for passing parameters to the method [`tui_open_help`]
#[derive(Clone, Debug)]
pub struct TuiOpenHelpParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_open_models`]
#[derive(Clone, Debug)]
pub struct TuiOpenModelsParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_open_sessions`]
#[derive(Clone, Debug)]
pub struct TuiOpenSessionsParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_open_themes`]
#[derive(Clone, Debug)]
pub struct TuiOpenThemesParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`tui_publish`]
#[derive(Clone, Debug)]
pub struct TuiPublishParams {
    pub directory: Option<String>,
    pub tui_publish_request: Option<models::TuiPublishRequest>
}

/// struct for passing parameters to the method [`tui_select_session`]
#[derive(Clone, Debug)]
pub struct TuiSelectSessionParams {
    pub directory: Option<String>,
    pub tui_select_session_request: Option<models::TuiSelectSessionRequest>
}

/// struct for passing parameters to the method [`tui_show_toast`]
#[derive(Clone, Debug)]
pub struct TuiShowToastParams {
    pub directory: Option<String>,
    pub tui_show_toast_request: Option<models::TuiShowToastRequest>
}

/// struct for passing parameters to the method [`tui_submit_prompt`]
#[derive(Clone, Debug)]
pub struct TuiSubmitPromptParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`vcs_get`]
#[derive(Clone, Debug)]
pub struct VcsGetParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`worktree_create`]
#[derive(Clone, Debug)]
pub struct WorktreeCreateParams {
    pub directory: Option<String>,
    pub worktree_create_input: Option<models::WorktreeCreateInput>
}

/// struct for passing parameters to the method [`worktree_list`]
#[derive(Clone, Debug)]
pub struct WorktreeListParams {
    pub directory: Option<String>
}

/// struct for passing parameters to the method [`worktree_remove`]
#[derive(Clone, Debug)]
pub struct WorktreeRemoveParams {
    pub directory: Option<String>,
    pub worktree_remove_input: Option<models::WorktreeRemoveInput>
}

/// struct for passing parameters to the method [`worktree_reset`]
#[derive(Clone, Debug)]
pub struct WorktreeResetParams {
    pub directory: Option<String>,
    pub worktree_reset_input: Option<models::WorktreeResetInput>
}


/// struct for typed errors of method [`app_agents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppAgentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`app_log`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppLogError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`app_skills`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppSkillsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthRemoveError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthSetError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`command_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommandListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigUpdateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`event_subscribe`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventSubscribeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`experimental_resource_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExperimentalResourceListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindFilesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_symbols`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindSymbolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`formatter_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FormatterStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalConfigGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_config_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalConfigUpdateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_dispose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalDisposeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_health`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalHealthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`instance_dispose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InstanceDisposeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAddError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_authenticate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthAuthenticateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_callback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthCallbackError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthRemoveError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_start`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthStartError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_connect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpConnectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_disconnect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpDisconnectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`part_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartDeleteError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`part_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`path_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PathGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_reply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionReplyError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_respond`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRespondError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_current`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectCurrentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderAuthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_oauth_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderOauthAuthorizeError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_oauth_callback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderOauthCallbackError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_connect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyConnectError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyCreateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyGetError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyRemoveError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyUpdateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`question_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuestionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`question_reject`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuestionRejectError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`question_reply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QuestionReplyError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_abort`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionAbortError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionCommandError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionCreateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionDeleteError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_diff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionDiffError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_fork`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionForkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_init`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionInitError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionMessageError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionMessagesError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionPromptError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_prompt_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionPromptAsyncError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_revert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionRevertError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_share`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionShareError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_shell`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionShellError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionStatusError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_summarize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionSummarizeError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_todo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionTodoError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_unrevert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUnrevertError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_unshare`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUnshareError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tool_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolIdsError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tool_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolListError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_append_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiAppendPromptError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_clear_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiClearPromptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_control_next`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiControlNextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_control_response`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiControlResponseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_execute_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiExecuteCommandError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_help`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenHelpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_models`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenModelsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenSessionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_themes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenThemesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_publish`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiPublishError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_select_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiSelectSessionError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_show_toast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiShowToastError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_submit_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiSubmitPromptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vcs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VcsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`worktree_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorktreeCreateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`worktree_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorktreeListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`worktree_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorktreeRemoveError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`worktree_reset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorktreeResetError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}


/// Get a list of all available AI agents in the OpenCode system.
pub async fn app_agents(configuration: &configuration::Configuration, params: AppAgentsParams) -> Result<Vec<models::Agent>, Error<AppAgentsError>> {

    let uri_str = format!("{}/agent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Agent&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Agent&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppAgentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Write a log entry to the server logs with specified level and metadata.
pub async fn app_log(configuration: &configuration::Configuration, params: AppLogParams) -> Result<bool, Error<AppLogError>> {

    let uri_str = format!("{}/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.app_log_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppLogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available skills in the OpenCode system.
pub async fn app_skills(configuration: &configuration::Configuration, params: AppSkillsParams) -> Result<Vec<models::AppSkills200ResponseInner>, Error<AppSkillsError>> {

    let uri_str = format!("{}/skill", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AppSkills200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AppSkills200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppSkillsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove authentication credentials
pub async fn auth_remove(configuration: &configuration::Configuration, params: AuthRemoveParams) -> Result<bool, Error<AuthRemoveError>> {

    let uri_str = format!("{}/auth/{providerID}", configuration.base_path, providerID=crate::apis::urlencode(params.provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set authentication credentials
pub async fn auth_set(configuration: &configuration::Configuration, params: AuthSetParams) -> Result<bool, Error<AuthSetError>> {

    let uri_str = format!("{}/auth/{providerID}", configuration.base_path, providerID=crate::apis::urlencode(params.provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.auth);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available commands in the OpenCode system.
pub async fn command_list(configuration: &configuration::Configuration, params: CommandListParams) -> Result<Vec<models::Command>, Error<CommandListError>> {

    let uri_str = format!("{}/command", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Command&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Command&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CommandListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current OpenCode configuration settings and preferences.
pub async fn config_get(configuration: &configuration::Configuration, params: ConfigGetParams) -> Result<models::Config, Error<ConfigGetError>> {

    let uri_str = format!("{}/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all configured AI providers and their default models.
pub async fn config_providers(configuration: &configuration::Configuration, params: ConfigProvidersParams) -> Result<models::ConfigProviders200Response, Error<ConfigProvidersError>> {

    let uri_str = format!("{}/config/providers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigProviders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigProviders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update OpenCode configuration settings and preferences.
pub async fn config_update(configuration: &configuration::Configuration, params: ConfigUpdateParams) -> Result<models::Config, Error<ConfigUpdateError>> {

    let uri_str = format!("{}/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.config);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get events
pub async fn event_subscribe(configuration: &configuration::Configuration, params: EventSubscribeParams) -> Result<models::Event, Error<EventSubscribeError>> {

    let uri_str = format!("{}/event", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Event`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Event`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventSubscribeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all available MCP resources from connected servers. Optionally filter by name.
pub async fn experimental_resource_list(configuration: &configuration::Configuration, params: ExperimentalResourceListParams) -> Result<std::collections::HashMap<String, models::McpResource>, Error<ExperimentalResourceListError>> {

    let uri_str = format!("{}/experimental/resource", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpResource&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpResource&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExperimentalResourceListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List files and directories in a specified path.
pub async fn file_list(configuration: &configuration::Configuration, params: FileListParams) -> Result<Vec<models::FileNode>, Error<FileListError>> {

    let uri_str = format!("{}/file", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("path", &params.path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FileNode&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FileNode&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Read the content of a specified file.
pub async fn file_read(configuration: &configuration::Configuration, params: FileReadParams) -> Result<models::FileContent, Error<FileReadError>> {

    let uri_str = format!("{}/file/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("path", &params.path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileReadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the git status of all files in the project.
pub async fn file_status(configuration: &configuration::Configuration, params: FileStatusParams) -> Result<Vec<models::File>, Error<FileStatusError>> {

    let uri_str = format!("{}/file/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::File&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::File&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for files or directories by name or pattern in the project directory.
pub async fn find_files(configuration: &configuration::Configuration, params: FindFilesParams) -> Result<Vec<String>, Error<FindFilesError>> {

    let uri_str = format!("{}/find/file", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    if let Some(ref param_value) = params.dirs {
        req_builder = req_builder.query(&[("dirs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.r#type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindFilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for workspace symbols like functions, classes, and variables using LSP.
pub async fn find_symbols(configuration: &configuration::Configuration, params: FindSymbolsParams) -> Result<Vec<models::Symbol>, Error<FindSymbolsError>> {

    let uri_str = format!("{}/find/symbol", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindSymbolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for text patterns across files in the project using ripgrep.
pub async fn find_text(configuration: &configuration::Configuration, params: FindTextParams) -> Result<Vec<models::FindText200ResponseInner>, Error<FindTextError>> {

    let uri_str = format!("{}/find", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("pattern", &params.pattern.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FindText200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FindText200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get formatter status
pub async fn formatter_status(configuration: &configuration::Configuration, params: FormatterStatusParams) -> Result<Vec<models::FormatterStatus>, Error<FormatterStatusError>> {

    let uri_str = format!("{}/formatter", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FormatterStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FormatterStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FormatterStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current global OpenCode configuration settings and preferences.
pub async fn global_config_get(configuration: &configuration::Configuration) -> Result<models::Config, Error<GlobalConfigGetError>> {

    let uri_str = format!("{}/global/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update global OpenCode configuration settings and preferences.
pub async fn global_config_update(configuration: &configuration::Configuration, params: GlobalConfigUpdateParams) -> Result<models::Config, Error<GlobalConfigUpdateError>> {

    let uri_str = format!("{}/global/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.config);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalConfigUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clean up and dispose all OpenCode instances, releasing all resources.
pub async fn global_dispose(configuration: &configuration::Configuration) -> Result<bool, Error<GlobalDisposeError>> {

    let uri_str = format!("{}/global/dispose", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalDisposeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Subscribe to global events from the OpenCode system using server-sent events.
pub async fn global_event(configuration: &configuration::Configuration) -> Result<models::GlobalEvent, Error<GlobalEventError>> {

    let uri_str = format!("{}/global/event", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlobalEvent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlobalEvent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get health information about the OpenCode server.
pub async fn global_health(configuration: &configuration::Configuration) -> Result<models::GlobalHealth200Response, Error<GlobalHealthError>> {

    let uri_str = format!("{}/global/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlobalHealth200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlobalHealth200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalHealthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clean up and dispose the current OpenCode instance, releasing all resources.
pub async fn instance_dispose(configuration: &configuration::Configuration, params: InstanceDisposeParams) -> Result<bool, Error<InstanceDisposeError>> {

    let uri_str = format!("{}/instance/dispose", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InstanceDisposeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get LSP server status
pub async fn lsp_status(configuration: &configuration::Configuration, params: LspStatusParams) -> Result<Vec<models::LspStatus>, Error<LspStatusError>> {

    let uri_str = format!("{}/lsp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LspStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LspStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LspStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Dynamically add a new Model Context Protocol (MCP) server to the system.
pub async fn mcp_add(configuration: &configuration::Configuration, params: McpAddParams) -> Result<std::collections::HashMap<String, models::McpStatus>, Error<McpAddError>> {

    let uri_str = format!("{}/mcp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.mcp_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start OAuth flow and wait for callback (opens browser)
pub async fn mcp_auth_authenticate(configuration: &configuration::Configuration, params: McpAuthAuthenticateParams) -> Result<models::McpStatus, Error<McpAuthAuthenticateError>> {

    let uri_str = format!("{}/mcp/{name}/auth/authenticate", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthAuthenticateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete OAuth authentication for a Model Context Protocol (MCP) server using the authorization code.
pub async fn mcp_auth_callback(configuration: &configuration::Configuration, params: McpAuthCallbackParams) -> Result<models::McpStatus, Error<McpAuthCallbackError>> {

    let uri_str = format!("{}/mcp/{name}/auth/callback", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.mcp_auth_callback_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthCallbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove OAuth credentials for an MCP server
pub async fn mcp_auth_remove(configuration: &configuration::Configuration, params: McpAuthRemoveParams) -> Result<models::McpAuthRemove200Response, Error<McpAuthRemoveError>> {

    let uri_str = format!("{}/mcp/{name}/auth", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpAuthRemove200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpAuthRemove200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start OAuth authentication flow for a Model Context Protocol (MCP) server.
pub async fn mcp_auth_start(configuration: &configuration::Configuration, params: McpAuthStartParams) -> Result<models::McpAuthStart200Response, Error<McpAuthStartError>> {

    let uri_str = format!("{}/mcp/{name}/auth", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpAuthStart200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpAuthStart200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthStartError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Connect an MCP server
pub async fn mcp_connect(configuration: &configuration::Configuration, params: McpConnectParams) -> Result<bool, Error<McpConnectError>> {

    let uri_str = format!("{}/mcp/{name}/connect", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpConnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disconnect an MCP server
pub async fn mcp_disconnect(configuration: &configuration::Configuration, params: McpDisconnectParams) -> Result<bool, Error<McpDisconnectError>> {

    let uri_str = format!("{}/mcp/{name}/disconnect", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpDisconnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the status of all Model Context Protocol (MCP) servers.
pub async fn mcp_status(configuration: &configuration::Configuration, params: McpStatusParams) -> Result<std::collections::HashMap<String, models::McpStatus>, Error<McpStatusError>> {

    let uri_str = format!("{}/mcp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a part from a message
pub async fn part_delete(configuration: &configuration::Configuration, params: PartDeleteParams) -> Result<bool, Error<PartDeleteError>> {

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}/part/{partID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id), messageID=crate::apis::urlencode(params.message_id), partID=crate::apis::urlencode(params.part_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PartDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a part in a message
pub async fn part_update(configuration: &configuration::Configuration, params: PartUpdateParams) -> Result<models::Part, Error<PartUpdateError>> {

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}/part/{partID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id), messageID=crate::apis::urlencode(params.message_id), partID=crate::apis::urlencode(params.part_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.part);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Part`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Part`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PartUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current working directory and related path information for the OpenCode instance.
pub async fn path_get(configuration: &configuration::Configuration, params: PathGetParams) -> Result<models::Path, Error<PathGetError>> {

    let uri_str = format!("{}/path", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Path`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Path`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PathGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all pending permission requests across all sessions.
pub async fn permission_list(configuration: &configuration::Configuration, params: PermissionListParams) -> Result<Vec<models::PermissionRequest>, Error<PermissionListError>> {

    let uri_str = format!("{}/permission", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PermissionRequest&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PermissionRequest&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PermissionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Approve or deny a permission request from the AI assistant.
pub async fn permission_reply(configuration: &configuration::Configuration, params: PermissionReplyParams) -> Result<bool, Error<PermissionReplyError>> {

    let uri_str = format!("{}/permission/{requestID}/reply", configuration.base_path, requestID=crate::apis::urlencode(params.request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.permission_reply_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PermissionReplyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Approve or deny a permission request from the AI assistant.
#[deprecated]
pub async fn permission_respond(configuration: &configuration::Configuration, params: PermissionRespondParams) -> Result<bool, Error<PermissionRespondError>> {

    let uri_str = format!("{}/session/{sessionID}/permissions/{permissionID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id), permissionID=crate::apis::urlencode(params.permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.permission_respond_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PermissionRespondError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the currently active project that OpenCode is working with.
pub async fn project_current(configuration: &configuration::Configuration, params: ProjectCurrentParams) -> Result<models::Project, Error<ProjectCurrentError>> {

    let uri_str = format!("{}/project/current", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectCurrentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of projects that have been opened with OpenCode.
pub async fn project_list(configuration: &configuration::Configuration, params: ProjectListParams) -> Result<Vec<models::Project>, Error<ProjectListError>> {

    let uri_str = format!("{}/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Project&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Project&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update project properties such as name, icon, and commands.
pub async fn project_update(configuration: &configuration::Configuration, params: ProjectUpdateParams) -> Result<models::Project, Error<ProjectUpdateError>> {

    let uri_str = format!("{}/project/{projectID}", configuration.base_path, projectID=crate::apis::urlencode(params.project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.project_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve available authentication methods for all AI providers.
pub async fn provider_auth(configuration: &configuration::Configuration, params: ProviderAuthParams) -> Result<std::collections::HashMap<String, Vec<models::ProviderAuthMethod>>, Error<ProviderAuthError>> {

    let uri_str = format!("{}/provider/auth", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::ProviderAuthMethod&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::ProviderAuthMethod&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available AI providers, including both available and connected ones.
pub async fn provider_list(configuration: &configuration::Configuration, params: ProviderListParams) -> Result<models::ProviderList200Response, Error<ProviderListError>> {

    let uri_str = format!("{}/provider", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Initiate OAuth authorization for a specific AI provider to get an authorization URL.
pub async fn provider_oauth_authorize(configuration: &configuration::Configuration, params: ProviderOauthAuthorizeParams) -> Result<models::ProviderAuthAuthorization, Error<ProviderOauthAuthorizeError>> {

    let uri_str = format!("{}/provider/{providerID}/oauth/authorize", configuration.base_path, providerID=crate::apis::urlencode(params.provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.provider_oauth_authorize_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderAuthAuthorization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderAuthAuthorization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderOauthAuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Handle the OAuth callback from a provider after user authorization.
pub async fn provider_oauth_callback(configuration: &configuration::Configuration, params: ProviderOauthCallbackParams) -> Result<bool, Error<ProviderOauthCallbackError>> {

    let uri_str = format!("{}/provider/{providerID}/oauth/callback", configuration.base_path, providerID=crate::apis::urlencode(params.provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.provider_oauth_callback_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderOauthCallbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Establish a WebSocket connection to interact with a pseudo-terminal (PTY) session in real-time.
pub async fn pty_connect(configuration: &configuration::Configuration, params: PtyConnectParams) -> Result<bool, Error<PtyConnectError>> {

    let uri_str = format!("{}/pty/{ptyID}/connect", configuration.base_path, ptyID=crate::apis::urlencode(params.pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyConnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new pseudo-terminal (PTY) session for running shell commands and processes.
pub async fn pty_create(configuration: &configuration::Configuration, params: PtyCreateParams) -> Result<models::Pty, Error<PtyCreateError>> {

    let uri_str = format!("{}/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.pty_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve detailed information about a specific pseudo-terminal (PTY) session.
pub async fn pty_get(configuration: &configuration::Configuration, params: PtyGetParams) -> Result<models::Pty, Error<PtyGetError>> {

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(params.pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all active pseudo-terminal (PTY) sessions managed by OpenCode.
pub async fn pty_list(configuration: &configuration::Configuration, params: PtyListParams) -> Result<Vec<models::Pty>, Error<PtyListError>> {

    let uri_str = format!("{}/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Pty&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Pty&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove and terminate a specific pseudo-terminal (PTY) session.
pub async fn pty_remove(configuration: &configuration::Configuration, params: PtyRemoveParams) -> Result<bool, Error<PtyRemoveError>> {

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(params.pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update properties of an existing pseudo-terminal (PTY) session.
pub async fn pty_update(configuration: &configuration::Configuration, params: PtyUpdateParams) -> Result<models::Pty, Error<PtyUpdateError>> {

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(params.pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.pty_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all pending question requests across all sessions.
pub async fn question_list(configuration: &configuration::Configuration, params: QuestionListParams) -> Result<Vec<models::QuestionRequest>, Error<QuestionListError>> {

    let uri_str = format!("{}/question", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::QuestionRequest&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::QuestionRequest&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QuestionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reject a question request from the AI assistant.
pub async fn question_reject(configuration: &configuration::Configuration, params: QuestionRejectParams) -> Result<bool, Error<QuestionRejectError>> {

    let uri_str = format!("{}/question/{requestID}/reject", configuration.base_path, requestID=crate::apis::urlencode(params.request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QuestionRejectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Provide answers to a question request from the AI assistant.
pub async fn question_reply(configuration: &configuration::Configuration, params: QuestionReplyParams) -> Result<bool, Error<QuestionReplyError>> {

    let uri_str = format!("{}/question/{requestID}/reply", configuration.base_path, requestID=crate::apis::urlencode(params.request_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.question_reply_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QuestionReplyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Abort an active session and stop any ongoing AI processing or command execution.
pub async fn session_abort(configuration: &configuration::Configuration, params: SessionAbortParams) -> Result<bool, Error<SessionAbortError>> {

    let uri_str = format!("{}/session/{sessionID}/abort", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionAbortError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a new command to a session for execution by the AI assistant.
pub async fn session_command(configuration: &configuration::Configuration, params: SessionCommandParams) -> Result<models::SessionPrompt200Response, Error<SessionCommandError>> {

    let uri_str = format!("{}/session/{sessionID}/command", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_command_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionPrompt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionPrompt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new OpenCode session for interacting with AI assistants and managing conversations.
pub async fn session_create(configuration: &configuration::Configuration, params: SessionCreateParams) -> Result<models::Session, Error<SessionCreateError>> {

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a session and permanently remove all associated data, including messages and history.
pub async fn session_delete(configuration: &configuration::Configuration, params: SessionDeleteParams) -> Result<bool, Error<SessionDeleteError>> {

    let uri_str = format!("{}/session/{sessionID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the file changes (diff) that resulted from a specific user message in the session.
pub async fn session_diff(configuration: &configuration::Configuration, params: SessionDiffParams) -> Result<Vec<models::FileDiff>, Error<SessionDiffError>> {

    let uri_str = format!("{}/session/{sessionID}/diff", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.message_id {
        req_builder = req_builder.query(&[("messageID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FileDiff&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FileDiff&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionDiffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new session by forking an existing session at a specific message point.
pub async fn session_fork(configuration: &configuration::Configuration, params: SessionForkParams) -> Result<models::Session, Error<SessionForkError>> {

    let uri_str = format!("{}/session/{sessionID}/fork", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_fork_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionForkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Analyze the current application and create an AGENTS.md file with project-specific agent configurations.
pub async fn session_init(configuration: &configuration::Configuration, params: SessionInitParams) -> Result<bool, Error<SessionInitError>> {

    let uri_str = format!("{}/session/{sessionID}/init", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_init_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionInitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all OpenCode sessions, sorted by most recently updated.
pub async fn session_list(configuration: &configuration::Configuration, params: SessionListParams) -> Result<Vec<models::Session>, Error<SessionListError>> {

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.roots {
        req_builder = req_builder.query(&[("roots", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Session&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Session&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a specific message from a session by its message ID.
pub async fn session_message(configuration: &configuration::Configuration, params: SessionMessageParams) -> Result<models::SessionMessages200ResponseInner, Error<SessionMessageError>> {

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id), messageID=crate::apis::urlencode(params.message_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionMessages200ResponseInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionMessages200ResponseInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all messages in a session, including user prompts and AI responses.
pub async fn session_messages(configuration: &configuration::Configuration, params: SessionMessagesParams) -> Result<Vec<models::SessionMessages200ResponseInner>, Error<SessionMessagesError>> {

    let uri_str = format!("{}/session/{sessionID}/message", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SessionMessages200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SessionMessages200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create and send a new message to a session, streaming the AI response.
pub async fn session_prompt(configuration: &configuration::Configuration, params: SessionPromptParams) -> Result<models::SessionPrompt200Response, Error<SessionPromptError>> {

    let uri_str = format!("{}/session/{sessionID}/message", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionPrompt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionPrompt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create and send a new message to a session asynchronously, starting the session if needed and returning immediately.
pub async fn session_prompt_async(configuration: &configuration::Configuration, params: SessionPromptAsyncParams) -> Result<(), Error<SessionPromptAsyncError>> {

    let uri_str = format!("{}/session/{sessionID}/prompt_async", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionPromptAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revert a specific message in a session, undoing its effects and restoring the previous state.
pub async fn session_revert(configuration: &configuration::Configuration, params: SessionRevertParams) -> Result<models::Session, Error<SessionRevertError>> {

    let uri_str = format!("{}/session/{sessionID}/revert", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_revert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionRevertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a shareable link for a session, allowing others to view the conversation.
pub async fn session_share(configuration: &configuration::Configuration, params: SessionShareParams) -> Result<models::Session, Error<SessionShareError>> {

    let uri_str = format!("{}/session/{sessionID}/share", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionShareError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a shell command within the session context and return the AI's response.
pub async fn session_shell(configuration: &configuration::Configuration, params: SessionShellParams) -> Result<models::AssistantMessage, Error<SessionShellError>> {

    let uri_str = format!("{}/session/{sessionID}/shell", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_shell_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AssistantMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AssistantMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionShellError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current status of all sessions, including active, idle, and completed states.
pub async fn session_status(configuration: &configuration::Configuration, params: SessionStatusParams) -> Result<std::collections::HashMap<String, models::SessionStatus>, Error<SessionStatusError>> {

    let uri_str = format!("{}/session/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::SessionStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::SessionStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a concise summary of the session using AI compaction to preserve key information.
pub async fn session_summarize(configuration: &configuration::Configuration, params: SessionSummarizeParams) -> Result<bool, Error<SessionSummarizeError>> {

    let uri_str = format!("{}/session/{sessionID}/summarize", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_summarize_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionSummarizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the todo list associated with a specific session, showing tasks and action items.
pub async fn session_todo(configuration: &configuration::Configuration, params: SessionTodoParams) -> Result<Vec<models::Todo>, Error<SessionTodoError>> {

    let uri_str = format!("{}/session/{sessionID}/todo", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Todo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Todo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionTodoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restore all previously reverted messages in a session.
pub async fn session_unrevert(configuration: &configuration::Configuration, params: SessionUnrevertParams) -> Result<models::Session, Error<SessionUnrevertError>> {

    let uri_str = format!("{}/session/{sessionID}/unrevert", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUnrevertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove the shareable link for a session, making it private again.
pub async fn session_unshare(configuration: &configuration::Configuration, params: SessionUnshareParams) -> Result<models::Session, Error<SessionUnshareError>> {

    let uri_str = format!("{}/session/{sessionID}/share", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUnshareError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update properties of an existing session, such as title or other metadata.
pub async fn session_update(configuration: &configuration::Configuration, params: SessionUpdateParams) -> Result<models::Session, Error<SessionUpdateError>> {

    let uri_str = format!("{}/session/{sessionID}", configuration.base_path, sessionID=crate::apis::urlencode(params.session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.session_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available tool IDs, including both built-in tools and dynamically registered tools.
pub async fn tool_ids(configuration: &configuration::Configuration, params: ToolIdsParams) -> Result<Vec<String>, Error<ToolIdsError>> {

    let uri_str = format!("{}/experimental/tool/ids", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToolIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of available tools with their JSON schema parameters for a specific provider and model combination.
pub async fn tool_list(configuration: &configuration::Configuration, params: ToolListParams) -> Result<Vec<models::ToolListItem>, Error<ToolListError>> {

    let uri_str = format!("{}/experimental/tool", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("provider", &params.provider.to_string())]);
    req_builder = req_builder.query(&[("model", &params.model.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ToolListItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ToolListItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToolListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Append prompt to the TUI
pub async fn tui_append_prompt(configuration: &configuration::Configuration, params: TuiAppendPromptParams) -> Result<bool, Error<TuiAppendPromptError>> {

    let uri_str = format!("{}/tui/append-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.find_text200_response_inner_path);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiAppendPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clear the prompt
pub async fn tui_clear_prompt(configuration: &configuration::Configuration, params: TuiClearPromptParams) -> Result<bool, Error<TuiClearPromptError>> {

    let uri_str = format!("{}/tui/clear-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiClearPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the next TUI (Terminal User Interface) request from the queue for processing.
pub async fn tui_control_next(configuration: &configuration::Configuration, params: TuiControlNextParams) -> Result<models::TuiControlNext200Response, Error<TuiControlNextError>> {

    let uri_str = format!("{}/tui/control/next", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TuiControlNext200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TuiControlNext200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiControlNextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a response to the TUI request queue to complete a pending request.
pub async fn tui_control_response(configuration: &configuration::Configuration, params: TuiControlResponseParams) -> Result<bool, Error<TuiControlResponseError>> {

    let uri_str = format!("{}/tui/control/response", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiControlResponseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a TUI command (e.g. agent_cycle)
pub async fn tui_execute_command(configuration: &configuration::Configuration, params: TuiExecuteCommandParams) -> Result<bool, Error<TuiExecuteCommandError>> {

    let uri_str = format!("{}/tui/execute-command", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tui_execute_command_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiExecuteCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the help dialog in the TUI to display user assistance information.
pub async fn tui_open_help(configuration: &configuration::Configuration, params: TuiOpenHelpParams) -> Result<bool, Error<TuiOpenHelpError>> {

    let uri_str = format!("{}/tui/open-help", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenHelpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the model dialog
pub async fn tui_open_models(configuration: &configuration::Configuration, params: TuiOpenModelsParams) -> Result<bool, Error<TuiOpenModelsError>> {

    let uri_str = format!("{}/tui/open-models", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenModelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the session dialog
pub async fn tui_open_sessions(configuration: &configuration::Configuration, params: TuiOpenSessionsParams) -> Result<bool, Error<TuiOpenSessionsError>> {

    let uri_str = format!("{}/tui/open-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the theme dialog
pub async fn tui_open_themes(configuration: &configuration::Configuration, params: TuiOpenThemesParams) -> Result<bool, Error<TuiOpenThemesError>> {

    let uri_str = format!("{}/tui/open-themes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenThemesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publish a TUI event
pub async fn tui_publish(configuration: &configuration::Configuration, params: TuiPublishParams) -> Result<bool, Error<TuiPublishError>> {

    let uri_str = format!("{}/tui/publish", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tui_publish_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiPublishError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Navigate the TUI to display the specified session.
pub async fn tui_select_session(configuration: &configuration::Configuration, params: TuiSelectSessionParams) -> Result<bool, Error<TuiSelectSessionError>> {

    let uri_str = format!("{}/tui/select-session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tui_select_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiSelectSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Show a toast notification in the TUI
pub async fn tui_show_toast(configuration: &configuration::Configuration, params: TuiShowToastParams) -> Result<bool, Error<TuiShowToastError>> {

    let uri_str = format!("{}/tui/show-toast", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.tui_show_toast_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiShowToastError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit the prompt
pub async fn tui_submit_prompt(configuration: &configuration::Configuration, params: TuiSubmitPromptParams) -> Result<bool, Error<TuiSubmitPromptError>> {

    let uri_str = format!("{}/tui/submit-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiSubmitPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve version control system (VCS) information for the current project, such as git branch.
pub async fn vcs_get(configuration: &configuration::Configuration, params: VcsGetParams) -> Result<models::VcsInfo, Error<VcsGetError>> {

    let uri_str = format!("{}/vcs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VcsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VcsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VcsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new git worktree for the current project and run any configured startup scripts.
pub async fn worktree_create(configuration: &configuration::Configuration, params: WorktreeCreateParams) -> Result<models::Worktree, Error<WorktreeCreateError>> {

    let uri_str = format!("{}/experimental/worktree", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.worktree_create_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Worktree`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Worktree`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorktreeCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all sandbox worktrees for the current project.
pub async fn worktree_list(configuration: &configuration::Configuration, params: WorktreeListParams) -> Result<Vec<String>, Error<WorktreeListError>> {

    let uri_str = format!("{}/experimental/worktree", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorktreeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a git worktree and delete its branch.
pub async fn worktree_remove(configuration: &configuration::Configuration, params: WorktreeRemoveParams) -> Result<bool, Error<WorktreeRemoveError>> {

    let uri_str = format!("{}/experimental/worktree", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.worktree_remove_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorktreeRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Reset a worktree branch to the primary default branch.
pub async fn worktree_reset(configuration: &configuration::Configuration, params: WorktreeResetParams) -> Result<bool, Error<WorktreeResetError>> {

    let uri_str = format!("{}/experimental/worktree/reset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.worktree_reset_input);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WorktreeResetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

